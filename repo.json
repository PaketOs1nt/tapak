{
    "name": "Paket Base Repo",
    "author": "@PaketPKSoftware",
    "modules": [
        {
            "name": "kahoot",
            "requirements": [
                {
                    "name": "pystyle",
                    "version": "2.9"
                },
                {
                    "name": "requests",
                    "version": "2.32.3"
                },
                {
                    "name": "websockets",
                    "version": "15.0"
                }
            ],
            "desc": "cheat for Kahoot from my github, for use run args in main tapak.py",
            "code": "import argparse\nimport asyncio\nimport json\nfrom dataclasses import dataclass\nfrom typing import Any, Callable, TypeVar\nimport pystyle\nimport requests\nimport websockets\nurl='https://create.kahoot.it/rest/kahoots/'\nwebsock_ip='127.14.88.67'\nwebsock_port=0x3a28\ntype SearchResult=dict[str, list[dict[str, dict[str, str]]]]\nF=TypeVar('F',bound=Callable[..., object])\n@dataclass\nclass Kahoot:\n uuid:str|None=None\n title:str|None=None\n author:str|None=None\n usage:str|None=None\n@dataclass\nclass Answer:\n text:str=''\n correct:bool=0x0\n@dataclass\nclass Question:\n text:str|None=None\n answers:list[Answer]|None=None\n def correct_index(self)->int|None:\n  if self.answers is None:\n   return None\n  for i, answer in enumerate(self.answers):\n   if answer.correct:\n    return i\n  return None\n def compile(self)->tuple:\n  return ((self.text or '').strip().lower(), tuple(sorted(((a.text or '').strip().lower() for a in self.answers or []))))\n @staticmethod\n def from_json(data:dict)->'Question':\n  choices:list[dict]=data.get('choices',[])\n  return Question(text=data.get('question','<unknown>'),answers=[Answer(text=choice.get('answer','<image>'),correct=choice.get('correct',0x0)) for choice in choices])\n@dataclass\nclass Result:\n correct:bool=0o0\n points:int=0o0\n total:int=0b0\n @staticmethod\n def from_json(data:dict)->'Result':\n  return Result(correct=data.get('correct',0x0),points=data.get('points',0b0),total=data.get('total',0x0))\n@dataclass\nclass Session:\n pin:str=''\n name:str=''\n @staticmethod\n def from_json(data:dict)->'Session':\n  return Session(pin=data.get('pin',''),name=data.get('name',''))\ndef getcol(status:int):\n return pystyle.Colors.green if status else pystyle.Colors.red\ndef search(q:str,limit:int=0b1100100)->list[Kahoot]:\n session=requests.Session()\n session.headers.update({'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36','Referer':'https://create.kahoot.it/','Accept-Language':'en-US,en;q=0.9'})\n params={'query':q,'limit':limit,'orderBy':'relevance','cursor':0x0,'searchCluster':0x1,'includeExtendedCounters':'false','inventoryItemId':'ANY'}\n response:SearchResult=session.get(url,params=params,timeout=0b1010).json()\n quizes=response.get('entities')\n kahoots=[]\n if not quizes:\n  return kahoots\n for quiz in quizes:\n  quiz=quiz['card']\n  kahoot=Kahoot()\n  kahoot.uuid=quiz.get('uuid','unknown')\n  kahoot.title=quiz.get('title','unknown')\n  kahoot.author=quiz.get('creator_username','unknown')\n  kahoot.usage=quiz.get('creatorPrimaryUsageType','unknown')\n  kahoots.append(kahoot)\n return kahoots\ndef answers(uuid:str)->tuple[list[Question], Kahoot]:\n req=requests.get(f'https://play.kahoot.it/rest/kahoots/{uuid}')\n data:dict[str, Any]=req.json()\n kahoot=Kahoot()\n kahoot.uuid=uuid\n kahoot.author=data['creator_username']\n kahoot.title=data['title']\n kahoot.usage=data['creator_primary_usage']\n _questions=data['questions']\n questions:list[Question]=[]\n for _quistion in _questions:\n  try:\n   questions.append(Question.from_json(_quistion))\n  except (IndexError, KeyError):\n   questions.append(Question(text=_quistion['question'],answers=[]))\n return (questions, kahoot)\ndef formatter(questions:list[Question],kahoot:Kahoot)->str:\n msg='<kahoot hack by @PaketPKSoftware>\\n'\n for a, b in kahoot.__dict__.items():\n  msg +=f'[kahoot] {a}: {b}\\n'\n msg +='\\n'\n for question in questions:\n  msg +=f'[question] {question.text}\\n'\n  if not question.answers:\n   msg +='[answer] No answers\\n'\n   continue\n  for answer in question.answers:\n   msg +=f'[{getcol(answer.correct)}{str(answer.correct).lower()}{pystyle.Colors.reset}] {answer.text}\\n'\n  msg +='\\n'\n return msg\ndef gentable(kahoots:list[Kahoot])->str:\n len_ui=max([len(k.uuid) if k.uuid else 0b0 for k in kahoots])\n len_ti=max([len(k.title) if k.title else 0b0 for k in kahoots])\n len_au=max([len(k.author) if k.author else 0b0 for k in kahoots])\n len_us=max([len(k.usage) if k.usage else 0o0 for k in kahoots])\n splitter=f\"+{'-'*(len_ui+0o2)}+{'-'*(len_ti+0o2)}+{'-'*(len_au+0o2)}+{'-'*(len_us+0o2)}+\"\n msg=splitter+'\\n'\n msg +=f\"| {'quiz id'.ljust(len_ui)} | {'title'.ljust(len_ti)} | {'author'.ljust(len_au)} | {'usage'.ljust(len_us)} |\\n\"\n msg +=splitter+'\\n'\n for kahoot in kahoots:\n  if not kahoot.uuid:\n   continue\n  if not kahoot.title:\n   continue\n  if not kahoot.author:\n   continue\n  if not kahoot.usage:\n   continue\n  msg +=f'| {kahoot.uuid.ljust(len_ui)} | {kahoot.title.ljust(len_ti)} | {kahoot.author.ljust(len_au)} | {kahoot.usage.ljust(len_us)} |\\n'\n return msg+splitter\nclass KahootSmartSearch:\n def __init__(self):\n  self.questions:list[Question]=[]\n  self.finaled=0x0\n  self.finish:Kahoot|None=None\n  self.cache:dict[str, list[Question]]={}\n def check(self,k:Kahoot)->bool:\n  if not k.uuid:\n   return 0x0\n  if k.uuid not in self.cache:\n   self.cache[k.uuid]=answers(k.uuid)[0x0]\n  answs=self.cache[k.uuid]\n  known={q.compile() for q in self.questions}\n  remote={q.compile() for q in answs}\n  return known.issubset(remote)\n def get(self,q:Question)->Kahoot|None:\n  if self.finaled:\n   if self.finish:\n    return self.finish\n  self.questions.append(q)\n  candidates=search(q.text if q.text else '',limit=0o12)\n  candidates=list(filter(self.check,candidates))\n  if len(candidates) == 0x1:\n   self.finaled=0b1\n   self.finish=candidates[0b0]\n  if len(candidates) > 0x0:\n   return candidates[0b0]\nclass KahootRemoteSession:\n def __init__(self,ws:websockets.ServerConnection):\n  self.ws=ws\n  self.kahoot=Kahoot()\n  self.questions:list[Question]=[]\n  self.session=Session()\n  self.total_points=0o0\n  self.current_question_index=0x0\n  self._on_question=lambda _:None\n  self._on_result=lambda _:None\n  self._on_pre_question=lambda _:None\n  self._on_session=lambda _:None\n  self._on_question_index=lambda _:None\n  self.loop=asyncio.get_event_loop()\n def on_question(self,f:F)->F:\n  self._on_question=f\n  return f\n def on_result(self,f:F)->F:\n  self._on_result=f\n  return f\n def on_pre_question(self,f:F)->F:\n  self._on_pre_question=f\n  return f\n def on_session(self,f:F)->F:\n  self._on_session=f\n  return f\n def on_question_index(self,f:F)->F:\n  self._on_question_index=f\n  return f\n async def process(self,msg:dict):\n  try:\n   match msg.get('type'):\n    case 'pre_question':\n     data=msg.get('data',{})\n     question=Question.from_json(data)\n     self._on_pre_question(question)\n    case 'question':\n     data=msg.get('data',{})\n     question=Question.from_json(data)\n     self.questions.append(question)\n     self._on_question(question)\n    case 'result':\n     data=msg.get('data',{})\n     result=Result.from_json(data)\n     self.total_points=result.total\n     self._on_result(result)\n    case 'session':\n     data=msg.get('data',{})\n     session=Session.from_json(data)\n     if not session == self.session:\n      self.session=session\n      self._on_session(session)\n    case 'question_index':\n     data=msg.get('data',0b0)\n     self.current_question_index=data\n     self._on_question_index(data)\n  except Exception as e:\n   raise e\n async def send(self,msg:str|bytes):\n  return self.ws.send(msg)\n async def a_show(self,idx:int):\n  await self.ws.send(json.dumps({'type':'show','data':idx}))\n def show(self,idx:int):\n  asyncio.run_coroutine_threadsafe(self.a_show(idx),self.loop)\n async def a_exec(self,code:str):\n  await self.ws.send(json.dumps({'type':'exec','data':code}))\n def exec(self,code:str):\n  asyncio.run_coroutine_threadsafe(self.a_exec(code),self.loop)\nclass KahootBackdoorServer:\n def __init__(self,on_client=lambda _:None):\n  self.sessions:list[KahootRemoteSession]=[]\n  self.limit=0o1\n  self.on_client=on_client\n def get(self)->KahootRemoteSession|None:\n  return self.sessions[0x0] if self.sessions else None\n async def handler(self,ws:websockets.ServerConnection):\n  session=KahootRemoteSession(ws)\n  if len(self.sessions) >= self.limit:\n   await ws.close()\n   return\n  self.sessions.append(session)\n  try:\n   self.on_client(session)\n   async for msg in ws:\n    await session.process(json.loads(msg))\n  finally:\n   self.sessions.remove(session)\n async def a_run(self):\n  self.loop=asyncio.get_event_loop()\n  async with websockets.serve(self.handler,websock_ip,websock_port):\n   await asyncio.Future()\n def run(self):\n  asyncio.run(self.a_run())\n async def a_remove(self,session:KahootRemoteSession):\n  await session.ws.close()\n def remove(self,session:KahootRemoteSession):\n  asyncio.run_coroutine_threadsafe(self.a_remove(session),self.loop)\ndef kahoot_backdoor_logger(session:KahootRemoteSession):\n print('[kahoot] new kahoot remote session connected')\n searcher=KahootSmartSearch()\n @session.on_pre_question\n def on_pre_question(question:Question):\n  print(f'[kahoot] [{session.session.name} : {session.session.pin}] new pre-question: {question.text}')\n  if not searcher.finaled:\n   searcher.get(question)\n   if searcher.finaled and searcher.finish and searcher.finish.uuid:\n    print(f'[kahoot] [{session.session.name} : {session.session.pin}] [{session.session.name} : {session.session.pin}] guessed kahoot: {searcher.finish.uuid} - {searcher.finish.title} by {searcher.finish.author}')\n @session.on_result\n def on_result(result:Result):\n  print(f'[kahoot] [{session.session.name} : {session.session.pin}] result: correct={result.correct}, points={result.points}, total={result.total}')\n @session.on_question\n def on_question(question:Question):\n  print(f'[kahoot] [{session.session.name} : {session.session.pin}] new question: {question.text}')\n  if searcher.finaled and searcher.finish and searcher.finish.uuid:\n   answers=searcher.cache[searcher.finish.uuid]\n   q=answers[session.current_question_index]\n   correct=q.correct_index()\n   if correct is not None:\n    session.show(correct)\n    if q.answers is not None:\n     for answer in q.answers:\n      print(f'[kahoot] [{session.session.name} : {session.session.pin}] [{getcol(answer.correct)}{str(answer.correct).lower()}{pystyle.Colors.reset}] {answer.text}')\n  elif question.answers:\n   for answer in question.answers:\n    print(f'[kahoot] [{session.session.name} : {session.session.pin}] [{getcol(answer.correct)}{str(answer.correct).lower()}{pystyle.Colors.reset}] {answer.text}')\n @session.on_session\n def on_session(s:Session):\n  print(f'[kahoot] loaded session [{s.name} : {s.pin}]')\ndef main():\n print(pystyle.Colors.reset,end='')\n parser=argparse.ArgumentParser(description='Kahoot Hack by @PaketPKSoftware')\n parser.add_argument('-search',type=str,help='Search quizid for questions')\n parser.add_argument('-scan',type=str,help='Scan answers from quizid')\n parser.add_argument('-server',action='store_true',help='Start Kahoot Backdoor Server for kahoot.js')\n args=parser.parse_args()\n if args.search:\n  kahoots=search(args.search)\n  if kahoots != []:\n   print(gentable(kahoots))\n  else:\n   print('[kahoot] quiz not found')\n if args.scan:\n  result=answers(args.scan)\n  message=formatter(*result)\n  print(message)\n if args.server:\n  server=KahootBackdoorServer(on_client=kahoot_backdoor_logger)\n  print(f'[kahoot] starting backdoor server on ws://{websock_ip}:{websock_port}')\n  server.run()\n if not any([args.search,args.scan,args.server]):\n  parser.print_help()\nif __name__ == '__main__':\n main()"
        },
        {
            "name": "test",
            "requirements": [],
            "desc": "test description for test file",
            "code": "print('hello world',__name__)"
        }
    ]
}