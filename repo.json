{
    "name": "Paket Base Repo",
    "author": "@PaketPKSoftware",
    "modules": [
        {
            "name": "kahoot",
            "requirements": [
                {
                    "name": "pystyle",
                    "version": "2.9"
                },
                {
                    "name": "requests",
                    "version": "2.32.3"
                },
                {
                    "name": "websockets",
                    "version": "15.0"
                }
            ],
            "desc": "cheat for Kahoot from my github, for use run args in main tapak.py",
            "code": "import argparse\nimport asyncio\nimport json\nfrom dataclasses import dataclass\nfrom typing import Any, Callable, TypeVar\nimport pystyle\nimport requests\nimport websockets\nurl='https://create.kahoot.it/rest/kahoots/'\nwebsock_ip='127.14.88.67'\nwebsock_port=0x3a28\ntype SearchResult=dict[str, list[dict[str, dict[str, str]]]]\nF=TypeVar('F',bound=Callable[..., object])\n@dataclass\nclass Kahoot:\n uuid:str|None=None\n title:str|None=None\n author:str|None=None\n usage:str|None=None\n@dataclass\nclass Answer:\n text:str=''\n correct:bool=0x0\n@dataclass\nclass Question:\n text:str|None=None\n answers:list[Answer]|None=None\n def correct_index(self)->int|None:\n  if self.answers is None:\n   return None\n  for i, answer in enumerate(self.answers):\n   if answer.correct:\n    return i\n  return None\n def compile(self)->tuple:\n  return ((self.text or '').strip().lower(), tuple(sorted(((a.text or '').strip().lower() for a in self.answers or []))))\n @staticmethod\n def from_json(data:dict)->'Question':\n  choices:list[dict]=data.get('choices',[])\n  return Question(text=data.get('question','<unknown>'),answers=[Answer(text=choice.get('answer','<image>'),correct=choice.get('correct',0x0)) for choice in choices])\n@dataclass\nclass Result:\n correct:bool=0b0\n points:int=0o0\n total:int=0x0\n @staticmethod\n def from_json(data:dict)->'Result':\n  return Result(correct=data.get('correct',0o0),points=data.get('points',0b0),total=data.get('total',0x0))\n@dataclass\nclass Session:\n pin:str=''\n name:str=''\n @staticmethod\n def from_json(data:dict)->'Session':\n  return Session(pin=data.get('pin',''),name=data.get('name',''))\ndef getcol(status:int):\n return pystyle.Colors.green if status else pystyle.Colors.red\ndef search(q:str,limit:int=0o144)->list[Kahoot]:\n session=requests.Session()\n session.headers.update({'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36','Referer':'https://create.kahoot.it/','Accept-Language':'en-US,en;q=0.9'})\n params={'query':q,'limit':limit,'orderBy':'relevance','cursor':0o0,'searchCluster':0x1,'includeExtendedCounters':'false','inventoryItemId':'ANY'}\n response:SearchResult=session.get(url,params=params,timeout=0b1010).json()\n quizes=response.get('entities')\n kahoots=[]\n if not quizes:\n  return kahoots\n for quiz in quizes:\n  quiz=quiz['card']\n  kahoot=Kahoot()\n  kahoot.uuid=quiz.get('uuid','unknown')\n  kahoot.title=quiz.get('title','unknown')\n  kahoot.author=quiz.get('creator_username','unknown')\n  kahoot.usage=quiz.get('creatorPrimaryUsageType','unknown')\n  kahoots.append(kahoot)\n return kahoots\ndef answers(uuid:str)->tuple[list[Question], Kahoot]:\n req=requests.get(f'https://play.kahoot.it/rest/kahoots/{uuid}')\n data:dict[str, Any]=req.json()\n kahoot=Kahoot()\n kahoot.uuid=uuid\n kahoot.author=data['creator_username']\n kahoot.title=data['title']\n kahoot.usage=data['creator_primary_usage']\n _questions=data['questions']\n questions:list[Question]=[]\n for _quistion in _questions:\n  try:\n   questions.append(Question.from_json(_quistion))\n  except (IndexError, KeyError):\n   questions.append(Question(text=_quistion['question'],answers=[]))\n return (questions, kahoot)\ndef formatter(questions:list[Question],kahoot:Kahoot)->str:\n msg='<kahoot hack by @PaketPKSoftware>\\n'\n for a, b in kahoot.__dict__.items():\n  msg +=f'[kahoot] {a}: {b}\\n'\n msg +='\\n'\n for question in questions:\n  msg +=f'[question] {question.text}\\n'\n  if not question.answers:\n   msg +='[answer] No answers\\n'\n   continue\n  for answer in question.answers:\n   msg +=f'[{getcol(answer.correct)}{str(answer.correct).lower()}{pystyle.Colors.reset}] {answer.text}\\n'\n  msg +='\\n'\n return msg\ndef gentable(kahoots:list[Kahoot])->str:\n len_ui=max([len(k.uuid) if k.uuid else 0b0 for k in kahoots])\n len_ti=max([len(k.title) if k.title else 0x0 for k in kahoots])\n len_au=max([len(k.author) if k.author else 0x0 for k in kahoots])\n len_us=max([len(k.usage) if k.usage else 0o0 for k in kahoots])\n splitter=f\"+{'-'*(len_ui+0b10)}+{'-'*(len_ti+0o2)}+{'-'*(len_au+0o2)}+{'-'*(len_us+0x2)}+\"\n msg=splitter+'\\n'\n msg +=f\"| {'quiz id'.ljust(len_ui)} | {'title'.ljust(len_ti)} | {'author'.ljust(len_au)} | {'usage'.ljust(len_us)} |\\n\"\n msg +=splitter+'\\n'\n for kahoot in kahoots:\n  if not kahoot.uuid:\n   continue\n  if not kahoot.title:\n   continue\n  if not kahoot.author:\n   continue\n  if not kahoot.usage:\n   continue\n  msg +=f'| {kahoot.uuid.ljust(len_ui)} | {kahoot.title.ljust(len_ti)} | {kahoot.author.ljust(len_au)} | {kahoot.usage.ljust(len_us)} |\\n'\n return msg+splitter\nclass KahootSmartSearch:\n def __init__(self):\n  self.questions:list[Question]=[]\n  self.finaled=0o0\n  self.finish:Kahoot|None=None\n  self.cache:dict[str, list[Question]]={}\n def check(self,k:Kahoot)->bool:\n  if not k.uuid:\n   return 0b0\n  if k.uuid not in self.cache:\n   self.cache[k.uuid]=answers(k.uuid)[0x0]\n  answs=self.cache[k.uuid]\n  known={q.compile() for q in self.questions}\n  remote={q.compile() for q in answs}\n  return known.issubset(remote)\n def get(self,q:Question)->Kahoot|None:\n  if self.finaled:\n   if self.finish:\n    return self.finish\n  self.questions.append(q)\n  candidates=search(q.text if q.text else '',limit=0xa)\n  candidates=list(filter(self.check,candidates))\n  if len(candidates) == 0o1:\n   self.finaled=0x1\n   self.finish=candidates[0b0]\n  if len(candidates) > 0x0:\n   return candidates[0x0]\nclass KahootRemoteSession:\n def __init__(self,ws:websockets.ServerConnection):\n  self.ws=ws\n  self.kahoot=Kahoot()\n  self.questions:list[Question]=[]\n  self.session=Session()\n  self.total_points=0b0\n  self.current_question_index=0x0\n  self._on_question=lambda _:None\n  self._on_result=lambda _:None\n  self._on_pre_question=lambda _:None\n  self._on_session=lambda _:None\n  self._on_question_index=lambda _:None\n  self.loop=asyncio.get_event_loop()\n def on_question(self,f:F)->F:\n  self._on_question=f\n  return f\n def on_result(self,f:F)->F:\n  self._on_result=f\n  return f\n def on_pre_question(self,f:F)->F:\n  self._on_pre_question=f\n  return f\n def on_session(self,f:F)->F:\n  self._on_session=f\n  return f\n def on_question_index(self,f:F)->F:\n  self._on_question_index=f\n  return f\n async def process(self,msg:dict):\n  try:\n   match msg.get('type'):\n    case 'pre_question':\n     data=msg.get('data',{})\n     question=Question.from_json(data)\n     self._on_pre_question(question)\n    case 'question':\n     data=msg.get('data',{})\n     question=Question.from_json(data)\n     self.questions.append(question)\n     self._on_question(question)\n    case 'result':\n     data=msg.get('data',{})\n     result=Result.from_json(data)\n     self.total_points=result.total\n     self._on_result(result)\n    case 'session':\n     data=msg.get('data',{})\n     session=Session.from_json(data)\n     if not session == self.session:\n      self.session=session\n      self._on_session(session)\n    case 'question_index':\n     data=msg.get('data',0b0)\n     self.current_question_index=data\n     self._on_question_index(data)\n  except Exception as e:\n   raise e\n async def send(self,msg:str|bytes):\n  return self.ws.send(msg)\n async def a_show(self,idx:int):\n  await self.ws.send(json.dumps({'type':'show','data':idx}))\n def show(self,idx:int):\n  asyncio.run_coroutine_threadsafe(self.a_show(idx),self.loop)\n async def a_exec(self,code:str):\n  await self.ws.send(json.dumps({'type':'exec','data':code}))\n def exec(self,code:str):\n  asyncio.run_coroutine_threadsafe(self.a_exec(code),self.loop)\nclass KahootBackdoorServer:\n def __init__(self,on_client=lambda _:None):\n  self.sessions:list[KahootRemoteSession]=[]\n  self.limit=0o1\n  self.on_client=on_client\n def get(self)->KahootRemoteSession|None:\n  return self.sessions[0o0] if self.sessions else None\n async def handler(self,ws:websockets.ServerConnection):\n  session=KahootRemoteSession(ws)\n  if len(self.sessions) >= self.limit:\n   await ws.close()\n   return\n  self.sessions.append(session)\n  try:\n   self.on_client(session)\n   async for msg in ws:\n    await session.process(json.loads(msg))\n  finally:\n   self.sessions.remove(session)\n async def a_run(self):\n  self.loop=asyncio.get_event_loop()\n  async with websockets.serve(self.handler,websock_ip,websock_port):\n   await asyncio.Future()\n def run(self):\n  asyncio.run(self.a_run())\n async def a_remove(self,session:KahootRemoteSession):\n  await session.ws.close()\n def remove(self,session:KahootRemoteSession):\n  asyncio.run_coroutine_threadsafe(self.a_remove(session),self.loop)\ndef kahoot_backdoor_logger(session:KahootRemoteSession):\n print('[kahoot] new kahoot remote session connected')\n searcher=KahootSmartSearch()\n @session.on_pre_question\n def on_pre_question(question:Question):\n  print(f'[kahoot] [{session.session.name} : {session.session.pin}] new pre-question: {question.text}')\n  if not searcher.finaled:\n   searcher.get(question)\n   if searcher.finaled and searcher.finish and searcher.finish.uuid:\n    print(f'[kahoot] [{session.session.name} : {session.session.pin}] [{session.session.name} : {session.session.pin}] guessed kahoot: {searcher.finish.uuid} - {searcher.finish.title} by {searcher.finish.author}')\n @session.on_result\n def on_result(result:Result):\n  print(f'[kahoot] [{session.session.name} : {session.session.pin}] result: correct={result.correct}, points={result.points}, total={result.total}')\n @session.on_question\n def on_question(question:Question):\n  print(f'[kahoot] [{session.session.name} : {session.session.pin}] new question: {question.text}')\n  if searcher.finaled and searcher.finish and searcher.finish.uuid:\n   answers=searcher.cache[searcher.finish.uuid]\n   q=answers[session.current_question_index]\n   correct=q.correct_index()\n   if correct is not None:\n    session.show(correct)\n    if q.answers is not None:\n     for answer in q.answers:\n      print(f'[kahoot] [{session.session.name} : {session.session.pin}] [{getcol(answer.correct)}{str(answer.correct).lower()}{pystyle.Colors.reset}] {answer.text}')\n  elif question.answers:\n   for answer in question.answers:\n    print(f'[kahoot] [{session.session.name} : {session.session.pin}] [{getcol(answer.correct)}{str(answer.correct).lower()}{pystyle.Colors.reset}] {answer.text}')\n @session.on_session\n def on_session(s:Session):\n  print(f'[kahoot] loaded session [{s.name} : {s.pin}]')\ndef main():\n print(pystyle.Colors.reset,end='')\n parser=argparse.ArgumentParser(description='Kahoot Hack by @PaketPKSoftware')\n parser.add_argument('-search',type=str,help='Search quizid for questions')\n parser.add_argument('-scan',type=str,help='Scan answers from quizid')\n parser.add_argument('-server',action='store_true',help='Start Kahoot Backdoor Server for kahoot.js')\n args=parser.parse_args()\n if args.search:\n  kahoots=search(args.search)\n  if kahoots != []:\n   print(gentable(kahoots))\n  else:\n   print('[kahoot] quiz not found')\n if args.scan:\n  result=answers(args.scan)\n  message=formatter(*result)\n  print(message)\n if args.server:\n  server=KahootBackdoorServer(on_client=kahoot_backdoor_logger)\n  print(f'[kahoot] starting backdoor server on ws://{websock_ip}:{websock_port}')\n  server.run()\n if not any([args.search,args.scan,args.server]):\n  parser.print_help()\nif __name__ == '__main__':\n main()"
        },
        {
            "name": "netdump",
            "requirements": [
                {
                    "name": "psutil",
                    "version": "7.0.0"
                },
                {
                    "name": "getmac",
                    "version": "0.9.5"
                }
            ],
            "desc": "Local network scanner by PaketSoftware! save all in files",
            "code": "import ipaddress\nimport logging\nimport os\nimport socket\nimport sys\nimport threading\nimport time\nimport urllib.request\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom logging.handlers import RotatingFileHandler\nworkth=0o1\nif sys.argv[-0o1].startswith('-'):\n external_ip=sys.argv[-0x1][0x1:]\nelse:\n external_ip=urllib.request.urlopen('https://ipinfo.io/ip').read().decode('utf-8')\ntry:\n import psutil\n from getmac import get_mac_address\nexcept ImportError:\n print('Installing missing packages...')\n os.system('python -m pip install psutil getmac')\n time.sleep(0b1)\n os.system(' '.join(sys.argv))\n time.sleep(0o1)\n exit()\ndumpdir=f'network_dump_{external_ip}'\nportsdir=os.path.join(dumpdir,'OPEN_PORTS')\nloaded_ips=0o0\nscanned_ips=0o0\nsocket.setdefaulttimeout(0x3)\n_cpu_count=os.cpu_count()\nglobalthreads=min(_cpu_count*0x40,0b10000000000)\nlocalthreads=min(_cpu_count*0o2,0b100000)\nlock=threading.Lock()\nflock=threading.Lock()\nstart_time=time.time()\nlog_file=os.path.join(dumpdir,'log.txt')\ntimeouts=[]\nmac_addresses={}\ndumped_dns={}\ndevices=[]\nistermux=0o0\nif '/data/data/com.termux/files/home' in os.path.expanduser('~'):\n istermux=0o1\n_DEVICE={'windows':[0b10001001,0b10001010,0b10001011,0b1011101100001,0b1011101100010,0b110100111101,0o207,0xc576,0x1bd],'ios':[0b1100000000000000,0b1111001001111110],'linux?':[0b10110,0o13560,0x15]}\n_PORTS={'veyon':[0x2b5c,0x2bc0,0o26044],'ssh':[0b10110],'telnet':[0o27],'anydesk':[0o15636],'msrpc':[0x87],'rpc':[0b1101111],'smb':[0x1bd],'netbios':[0b10001001,0b10001010,0x8b],'rdp':[0o6475],'winrm':[0o13541,0b1011101100010],'iphone':[0o140000,0b1111001001111110],'ftp':[0b10101],'vnc':[0x16a8,0o13414],'http':[0x50],'https':[0x1bb],'upnp':[0x76c,0o11610,0o5465],'heyec':[0xc576],'termux-backdoor':[0xbdbd],'x11':[0x1770],'radmin':[0x1323]}\nvulnerabilities_ports=[0o25534,0x2bc0,0x2c24,0b1011110110111101,0b1100010101110110]\nports={port:service for service, _ports in _PORTS.items() for port in _ports}\ndev_ports={port:service for service, _ports in _DEVICE.items() for port in _ports}\nclass Network:\n @staticmethod\n def getranges():\n  networks=[]\n  for _, addrs in psutil.net_if_addrs().items():\n   for addr in addrs:\n    if addr.family == socket.AF_INET:\n     ip=addr.address\n     try:\n      if not ip.startswith('127.') and (not ip.startswith('169.254.')) and (not ip.startswith('172.21.')):\n       network=ipaddress.IPv4Network(f'{ip}/{addr.netmask}',strict=0o0)\n       if not network.is_loopback and (not network.is_link_local):\n        nrange=str(network.network_address)+'/'+str(network.prefixlen)\n        if istermux:\n         if nrange.endswith('/8'):\n          continue\n        if nrange != '172.24.16.0/20':\n         networks.append(nrange)\n         logging.info(f'found ip range {nrange}')\n     except ValueError:\n      pass\n  return networks\n @staticmethod\n def scanport(host:str,port:int)->bool:\n  global timeouts\n  try:\n   _start_time=time.time()\n   with socket.socket() as s:\n    result=s.connect_ex((host, port))\n   opened=result == 0x0\n   if opened:\n    timeout=time.time()-_start_time\n    if timeout != 0.0:\n     with lock:\n      timeouts.append(timeout)\n    else:\n     logging.info(f'{host}:{port} timeout very small')\n   return opened\n  except:\n   return 0x0\n @staticmethod\n def getservice(port:int)->str:\n  try:\n   portname=socket.getservbyport(port,'tcp')\n  except:\n   portname='unknown'\n  return ports.get(port,portname)\ndef progress():\n global loaded_ips,scanned_ips,workth\n while workth:\n  if workth:\n   print(f'time: {time.time()-start_time:.2f}, loaded ips: {loaded_ips}, scanned ips: {scanned_ips} [{loaded_ips}/{scanned_ips}]')\n   time.sleep(0x3)\ndef localscanner(ip:str):\n global scanned_ips,mac_addresses,dumped_dns,devices\n try:\n  open_ports=[]\n  hostname=None\n  mac_address=get_mac_address(ip=ip)\n  if mac_address:\n   with lock:\n    mac_addresses[ip]=mac_address\n  with ThreadPoolExecutor(localthreads,thread_name_prefix='local_scan') as local_executor:\n   raw_ports=local_executor.map(Network.scanport,[ip]*len(ports.keys()),ports.keys())\n  for c_port, c_status in zip(ports.keys(),raw_ports):\n   if c_status:\n    open_ports.append(c_port)\n  try:\n   hostname=socket.gethostbyaddr(ip)[0b0]\n   with lock:\n    dumped_dns[ip]=hostname\n  except:\n   pass\n  if open_ports != []:\n   dir_path=os.path.join(dumpdir,ip)\n   os.makedirs(dir_path,exist_ok=0x1)\n   local_dev=[]\n   with open(os.path.join(dir_path,'ports.txt'),'w',encoding='utf-8') as f:\n    temp=''\n    for port in open_ports:\n     port_file=os.path.join(portsdir,f'{port}.txt')\n     service=Network.getservice(port)\n     temp +=f'{port}: {service}\\n'\n     if os.path.exists(port_file):\n      open_mode='a'\n     else:\n      open_mode='w'\n     with flock:\n      with open(port_file,mode=open_mode,encoding='utf-8') as portf:\n       portf.write(f'{ip}\\n')\n     if port in vulnerabilities_ports:\n      vulnerabilities_file=os.path.join(dumpdir,f'vulnerable_ips.txt')\n      logging.info(f'found vulnerable port on {ip} - {port}')\n      if os.path.exists(vulnerabilities_file):\n       open_mode='a'\n      else:\n       open_mode='w'\n      with flock:\n       with open(vulnerabilities_file,mode=open_mode,encoding='utf-8') as portf:\n        portf.write(f'{ip} - {port} ({Network.getservice(port)})\\n')\n     device=dev_ports.get(port)\n     if device:\n      local_dev.append(device)\n    f.write(temp)\n   if local_dev:\n    devices.append(Counter(local_dev).most_common(0b1)[0x0][0x0])\n   if hostname:\n    with open(os.path.join(dir_path,'domain.txt'),'w',encoding='utf-8') as f:\n     f.write(hostname)\n   if mac_address:\n    with open(os.path.join(dir_path,'mac.txt'),'w',encoding='utf-8') as f:\n     f.write(mac_address)\n  with lock:\n   scanned_ips +=0b1\n except BaseException as e:\n  logging.error(f'error on localscanner ({ip}): {e}')\ndef main():\n global loaded_ips,scanned_ips,timeouts,globalthreads,dumped_dns,devices,workth\n print(f'current network: {external_ip}')\n thh=threading.Thread(target=progress,daemon=0o1)\n thh.start()\n os.makedirs(dumpdir,exist_ok=0o1)\n os.makedirs(portsdir,exist_ok=0b1)\n handler=RotatingFileHandler(log_file,mode='w',maxBytes=0xa**0x6,backupCount=0o5)\n logging.basicConfig(handlers=[handler],level=logging.INFO,format='%(asctime)s - %(levelname)s - %(message)s',datefmt='%Y-%m-%d %H:%M:%S')\n ip_ranges=Network.getranges()\n for addr in ip_ranges:\n  if addr.endswith('/8'):\n   globalthreads=min(_cpu_count*0b1000000,0x200)\n with ThreadPoolExecutor(globalthreads,thread_name_prefix='global_scan') as main_executor:\n  for addr_network in ip_ranges:\n   network=ipaddress.IPv4Network(addr_network)\n   for ip_obj in network.hosts():\n    ip=ip_obj.compressed\n    main_executor.submit(localscanner,ip)\n    loaded_ips +=0o1\n  main_executor.shutdown(wait=0x1)\n with open(os.path.join(dumpdir,'summary.txt'),'w',encoding='utf-8') as summary:\n  summary.write(f'total time: {time.time()-start_time:.2f} seconds\\n')\n  summary.write(f'total loaded IPs: {loaded_ips}\\n')\n  summary.write(f'total scanned IPs: {scanned_ips}\\n')\n  if timeouts:\n   avg_timeout=sum(timeouts)/len(timeouts)\n   summary.write(f'average connection timeout: {avg_timeout}\\n')\n  else:\n   summary.write('average connection timeout: N/A\\n')\n mac_path=os.path.join(dumpdir,'mac_addresses.txt')\n mac_exists=os.path.exists(mac_path)\n dns_path=os.path.join(dumpdir,'dumped_dns.txt')\n dns_exists=os.path.exists(dns_path)\n with open(mac_path,'r+' if mac_exists else 'w',encoding='utf-8') as macf:\n  if not mac_exists:\n   for ip, mac in mac_addresses.items():\n    macf.write(f'{ip}: {mac}\\n')\n  else:\n   f_dat=macf.read()\n   for ip, mac in mac_addresses.items():\n    t_dat=f'{ip}: {mac}\\n'\n    if not t_dat in f_dat:\n     macf.write(t_dat)\n with open(dns_path,'r+' if dns_exists else 'w',encoding='utf-8') as dnsf:\n  if not dns_exists:\n   for ip, domain in dumped_dns.items():\n    dnsf.write(f'{ip}: {domain}\\n')\n  else:\n   f_dat=dnsf.read()\n   for ip, domain in dumped_dns.items():\n    t_dat=f'{ip}: {domain}\\n'\n    if not t_dat in f_dat:\n     dnsf.write(t_dat)\n with open(os.path.join(dumpdir,'ip_ranges.txt'),'w',encoding='utf-8') as rangef:\n  rangef.write('\\n'.join(ip_ranges))\n device_stats={}\n for device in devices:\n  if device in device_stats:\n   device_stats[device] +=0o1\n  else:\n   device_stats[device]=0b1\n with open(os.path.join(dumpdir,'device_statistics.txt'),'w',encoding='utf-8') as f:\n  for device, count in device_stats.items():\n   f.write(f'{device}: {count}\\n')\n workth=0x0\n thh.join()\nif __name__ == '__main__':\n main()"
        },
        {
            "name": "test",
            "requirements": [],
            "desc": "test description for test file",
            "code": "print('hello world',__name__)"
        }
    ]
}